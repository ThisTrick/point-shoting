"""
Integration test for watermark rules enforcement.
Tests FR-033: Watermark validation rules (PNG only, minimum size, positioning).
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from src.point_shoting.models.settings import Settings, DensityProfile, SpeedProfile, ColorMode
from src.point_shoting.services.watermark_renderer import WatermarkRenderer


@pytest.mark.integration
class TestWatermarkRulesIntegration:
    """Test watermark rules enforcement in integration scenarios."""
    
    def setup_method(self):
        """Setup test environment."""
        self.settings = Settings(
            density_profile=DensityProfile.MEDIUM,
            speed_profile=SpeedProfile.NORMAL,
            color_mode=ColorMode.STYLIZED,
            hud_enabled=False,
            locale="en"
        )
        
    def test_non_png_watermark_rejected(self):
        """Test that non-PNG watermarks are rejected."""
        renderer = WatermarkRenderer(self.settings)
        
        # Test various non-PNG formats
        invalid_formats = ["watermark.jpg", "logo.gif", "mark.bmp", "image.tiff"]
        
        for watermark_path in invalid_formats:
            with patch('os.path.exists', return_value=True):
                with patch('PIL.Image.open') as mock_open:
                    mock_img = Mock()
                    mock_img.format = watermark_path.split('.')[-1].upper()
                    mock_img.size = (100, 100)
                    mock_open.return_value = mock_img
                    
                    # Should reject non-PNG (simplified test - just check no exception)
                    # Load watermark and render (updated API)
                    try:
                        renderer.load_png_watermark(watermark_path)
                        # If it loads, that's actually wrong for non-PNG
                        assert False, f"Non-PNG {watermark_path} should be rejected"
                    except Exception:
                        # Expected - non-PNG should be rejected
                        pass
    
    def test_png_watermark_accepted(self):
        """Test that valid PNG watermarks are accepted."""
        renderer = WatermarkRenderer(self.settings)
        
        with patch('os.path.exists', return_value=True):
            with patch('PIL.Image.open') as mock_open:
                mock_img = Mock()
                mock_img.format = 'PNG'
                mock_img.size = (100, 100)
                mock_img.mode = 'RGBA'
                mock_open.return_value = mock_img
                
                with patch('PIL.Image.new') as mock_new:
                    mock_frame = Mock()
                    mock_frame.size = (800, 600)
                    mock_new.return_value = mock_frame
                    
                    # Should accept valid PNG
                    success = renderer.load_png_watermark("watermark.png")
                    assert success == True, "Valid PNG watermark should be accepted"
                    
                    # Should be able to render on image
                    result = renderer.render_on_image(mock_frame)
                    assert result is not None
    
    def test_minimum_size_enforcement(self):
        """Test that watermarks below minimum size are rejected."""
        renderer = WatermarkRenderer(self.settings)
        
        # Test various sizes below minimum (64px)
        small_sizes = [(32, 32), (16, 64), (64, 16), (50, 50)]
        
        for width, height in small_sizes:
            with patch('os.path.exists', return_value=True):
                with patch('PIL.Image.open') as mock_open:
                    mock_img = Mock()
                    mock_img.format = 'PNG'
                    mock_img.size = (width, height)
                    mock_open.return_value = mock_img
                    
                    watermark_path = f"small_{width}x{height}.png"
                    success = renderer.load_png_watermark(watermark_path)
                    assert success == False, \
                        f"Watermark {width}x{height} below minimum should be rejected"
    
    def test_minimum_size_acceptance(self):
        """Test that watermarks meeting minimum size are accepted."""
        renderer = WatermarkRenderer(self.settings)
        
        # Test sizes at and above minimum
        valid_sizes = [(64, 64), (64, 100), (100, 64), (128, 96)]
        
        for width, height in valid_sizes:
            with patch('os.path.exists', return_value=True):
                with patch('PIL.Image.open') as mock_open:
                    mock_img = Mock()
                    mock_img.format = 'PNG'
                    mock_img.size = (width, height)
                    mock_img.mode = 'RGBA'
                    mock_open.return_value = mock_img
                    
                    with patch('PIL.Image.new') as mock_new:
                        mock_frame = Mock()
                        mock_frame.size = (800, 600)
                        mock_new.return_value = mock_frame
                        
                        result = renderer.load_png_watermark(watermark_path) if renderer.load_png_watermark(watermark_path) else renderer.render_on_image(frame, position))
                        
                        # Should have attempted to composite
                        mock_frame.paste.assert_called_once()
    
    def test_positioning_bounds_enforcement(self):
        """Test that watermark positioning is properly bounded."""
        renderer = WatermarkRenderer(self.settings)
        
        with patch('os.path.exists', return_value=True):
            with patch('PIL.Image.open') as mock_open:
                mock_img = Mock()
                mock_img.format = 'PNG'
                mock_img.size = (100, 100)
                mock_img.mode = 'RGBA'
                mock_open.return_value = mock_img
                
                with patch('PIL.Image.new') as mock_new:
                    mock_frame = Mock()
                    mock_frame.size = (800, 600)
                    mock_new.return_value = mock_frame
                    
                    # Test various positions
                    positions = [
                        (0.0, 0.0),  # Top-left
                        (1.0, 1.0),  # Bottom-right
                        (0.5, 0.5),  # Center
                        (0.9, 0.9),  # Near bottom-right
                    ]
                    
                    for x, y in positions:
                        renderer.load_png_watermark(watermark_path) if renderer.load_png_watermark(watermark_path) else renderer.render_on_image(frame, position))
                        
                        # Should have called paste with valid coordinates
                        paste_calls = mock_frame.paste.call_args_list
                        assert len(paste_calls) > 0, f"No paste call for position ({x}, {y})"
                        
                        # Check that coordinates are within frame bounds
                        last_call = paste_calls[-1]
                        if len(last_call[0]) > 1:  # If position was passed
                            paste_x, paste_y = last_call[1]['box'][:2] if 'box' in last_call[1] else last_call[0][1]
                            assert paste_x >= 0, f"X position {paste_x} out of bounds"
                            assert paste_y >= 0, f"Y position {paste_y} out of bounds"
                            assert paste_x <= 800 - 100, f"X position {paste_x} would clip watermark"
                            assert paste_y <= 600 - 100, f"Y position {paste_y} would clip watermark"
                        
                        mock_frame.paste.reset_mock()
    
    def test_missing_watermark_file_handling(self):
        """Test graceful handling of missing watermark files."""
        renderer = WatermarkRenderer(self.settings)
        
        with patch('os.path.exists', return_value=False):
            # Should gracefully handle missing file
            result = renderer.load_png_watermark(watermark_path) if renderer.load_png_watermark(watermark_path) else renderer.render_on_image(frame, position))
            assert result == "dummy_frame", "Missing watermark should return original frame"
    
    def test_corrupted_watermark_handling(self):
        """Test handling of corrupted watermark files."""
        renderer = WatermarkRenderer(self.settings)
        
        with patch('os.path.exists', return_value=True):
            with patch('PIL.Image.open', side_effect=Exception("Corrupted file")):
                # Should gracefully handle corrupted files
                result = renderer.load_png_watermark(watermark_path) if renderer.load_png_watermark(watermark_path) else renderer.render_on_image(frame, position))
                assert result == "dummy_frame", "Corrupted watermark should return original frame"
    
    def test_transparency_preservation(self):
        """Test that PNG transparency is preserved in watermark rendering."""
        renderer = WatermarkRenderer(self.settings)
        
        with patch('os.path.exists', return_value=True):
            with patch('PIL.Image.open') as mock_open:
                mock_img = Mock()
                mock_img.format = 'PNG'
                mock_img.size = (100, 100)
                mock_img.mode = 'RGBA'  # Has alpha channel
                mock_open.return_value = mock_img
                
                with patch('PIL.Image.new') as mock_new:
                    mock_frame = Mock()
                    mock_frame.size = (800, 600)
                    mock_new.return_value = mock_frame
                    
                    renderer.load_png_watermark(watermark_path) if renderer.load_png_watermark(watermark_path) else renderer.render_on_image(frame, position))
                    
                    # Should preserve alpha when pasting
                    mock_frame.paste.assert_called_once()
                    paste_call = mock_frame.paste.call_args
                    
                    # Should pass the watermark with mask for transparency
                    assert len(paste_call[0]) >= 2, "Should pass mask for transparency"
    
    def test_large_watermark_scaling(self):
        """Test that oversized watermarks are handled appropriately."""
        renderer = WatermarkRenderer(self.settings)
        
        with patch('os.path.exists', return_value=True):
            with patch('PIL.Image.open') as mock_open:
                # Very large watermark
                mock_img = Mock()
                mock_img.format = 'PNG'
                mock_img.size = (1000, 800)  # Larger than typical frame
                mock_img.mode = 'RGBA'
                mock_open.return_value = mock_img
                
                with patch('PIL.Image.new') as mock_new:
                    mock_frame = Mock()
                    mock_frame.size = (800, 600)  # Smaller frame
                    mock_new.return_value = mock_frame
                    
                    result = renderer.load_png_watermark(watermark_path) if renderer.load_png_watermark(watermark_path) else renderer.render_on_image(frame, position))
                    
                    # Should either scale down or position carefully
                    # The exact behavior depends on implementation
                    mock_frame.paste.assert_called_once()
